{"componentChunkName":"component---src-templates-page-template-js","path":"/buildingACloudMigrationPlatformPart2OrchestrationAndExecution","result":{"pageContext":{"page":{"author":"Arun Madhavan","content":"<p>In the <a href=\"https://techmusings.dev/buildingACloudMigrationPlatformPart1ProvisioningTheInfrastructure\">Part 1</a> of the blog, we saw the motivation behind the project and how we built the Step Executor for executing Terrform scripts.\nIn this post we'll look into the <strong>Orchestrator</strong> which helps in orchestration of multiple terraform scripts and provide the collective results back to the calling place. </p>\n<h2>TLDR</h2>\n<p>A component creation may need other pre-requisites to be created. The orchestrator, identifies the execution plan to create the component by orchestrating it's dependencies before creating the intended component. The design is motivated from how a CI/CD pipeline is built with multiple steps and running them in series.</p>\n<h2>Component dependencies</h2>\n<p>A typical use case we were trying to solve was a request for provisioning components such as a Cloud SQL DB. The creation of this component will require inputs such as </p>\n<ul>\n<li>Type of Database</li>\n<li>Database Name</li>\n<li>Admin user name</li>\n<li>Project under which it needs to be created</li>\n<li>DB Version</li>\n<li>Charset</li>\n<li>Collation</li>\n<li>Disktype</li>\n<li>Activation policy\netc... </li>\n</ul>\n<p>Of these, some can be safely defaulted at the organization level. These defaults being part of terraform script would be a bad idea as it would bring in a tight coupling. Similarly some of the inputs cannot be defaulted and needs to flow in as user inputs. </p>\n<p>Apart from this, the creation of the component would need other dependent components to be created first. For example, the postgres DB would require a VPC and Subnet to be created before provisioning the DB itself. This can be handled either at the terraform script where the prerequisites are provisioned before the actual component. But in most cases, the VPC and subnets are pre-created and may not be required to recreate. Therefore keeping these component provisioning as part of the same terraform script would create a tight coupling. </p>\n<p>We now have 2 important considerations for creating a component</p>\n<ol>\n<li>Safe defaults of inputs at an organization level for each component</li>\n<li>List of dependent infra components to be provisioned before creating the intentended component.</li>\n</ol>\n<p>To solve this, we generated an \"Execution Plan\" for the component's provisioning. With the execition plan in place, the Orchestrator would orchestrate the steps in them by calling step executor and collating it's results. </p>\n<h2>Execution Plan</h2>\n<p>I had mentioned that the overall design was inspited by a CI/CD pipeline where a pipeline can have many tasks which configured to be exeuted in parallel or series and often there are cases where the output from a previous step are used as input in subsequent steps. </p>\n<p>Similarly we designed our system to have a root component called the \"Execution Plan\" or just a \"Plan\" for brievity. The plan consists of individual steps. Each step in this case are individual terraform executions ( executed by Step Executor ). A Plan will have user inputs, which as discussed earlier will have definition of all possible inputs required for creation of the component.  </p>\n<p>Similarly each step will have step inputs, which would be passed down to the Step executor for executing the terraform script. Interestingly the step's input can come from either the plan's input or from the output of each step. Thus the output from each of these steps were also defined.\nA step input mapping was defined to tell whether the step gets its input from user or a previous step's output. </p>\n<p>The complete plan's output was captured which is basically outputs from individual steps. Our overall model looked like below. </p>\n<p><img src=\"./images/migrationPlatform/ExecutionPlan-ER.svg\"></p>\n<h2>Handling the inputs</h2>\n<p>By defining the Plan, we were able to solve the component pre-requisite identification. We still had to provide the system the ability to provide defaults. For this, we captured for every plan's input a Plan Input Default values. </p>\n<p>We also realised that some of the inputs being present or absent would change our execution plan. For example, A VPC or a subnet value could be passed as a user input if they are available. Their presence or absence would lead to changes to the execution plan where we may or may not need included or execulude the dependent steps. </p>\n<p>We captured this through a nullable field referencing a step or plan input. This helped us identify the steps that can be avoided in case the value gets supplied. We handled the code to pass \"user input\" rather than from the \"previous step output\" in these cases based for step input. </p>\n<p>These changes helped us in </p>\n<ul>\n<li>Fully flexible and indepdendent Terraform scripts</li>\n<li>Configurable defaults stored as part of tables</li>\n<li>Generation of \"Execution Plan\" depending on the inputs</li>\n</ul>\n<h2>Executing the Plan</h2>\n<p>With the above changes, we were able to successfully capture the information required to generate a plan and execute it. Execution of the plan was done at a request level. Every request requires capturing information of Plan Inputs, Step Inputs, step outputs and the plan output. </p>\n<p>For this reason, we created a set of \"Value\" tables, which would be used to capture the above mentioned information. All the information across these tables were linked together using a \"traceId\" which is passed from the caller's location ( Mediator ). The traceId is also passed down to the Step Executor, which uses it as part of its calls back to the \"Orchestrator\". </p>\n<p><img src=\"./images/migrationPlatform/ValueTables.svg\"></p>\n<p>Once all the steps in the Plan were executed, the Plan output values were populated and a call is made back to Mediator with the traceID and the output values of the Plan. </p>\n<h2>Changes to Step Executor</h2>\n<p>We created a spring boot application, created the tables with Flyway migration, persisted our data into a postgres DB. While doing so, we continued to keep the stepName consistent between Step Executor and Orchestrator. This enabled Step Executor to identify the scripts correctly based on the name that was passed to it. </p>\n<p>But as we started splitting, refactoring and adding more scripts, we realised that human error is something that cannot be avoided and this solution will not scale. </p>\n<p>So we moved the terraform scripts to a google object store. The location of these script were captured as part of the step information. This information was  inturn passed down to the \"Step Executor\" as input. The step executor's body changed as shown below. </p>\n<pre><code>{\n    \"traceId\": \"traceID from the requesting system\", \n    \"stepLocation\": \"location of the script in google object store\"\n    \"auth\": { \"type\": \"service_account\",\n      \"project_id\": \"&#x3C;project id from GCP>\",\n      \"private_key_id\": \"&#x3C;keyId>\",\n      \"private_key\": \"&#x3C;Private Key>\",\n      \"client_email\": \"&#x3C;service email>\",\n      \"client_id\": \"&#x3C;GCP Client Id>\",\n      \"auth_uri\": \"https://accounts.google.com/o/oauth2/auth\",\n      \"token_uri\": \"https://oauth2.googleapis.com/token\",\n      \"auth_provider_x509_cert_url\": \"https://www.googleapis.com/oauth2/v1/certs\",\n      \"client_x509_cert_url\": \"&#x3C;client-cert-url>\"\n    },\n    \"inputs\": [{\n        \"label\":\"input key as per terraform script\",\n        \"value\": \"value for the given label\"\n    }, ...]\n}\n</code></pre>\n<p>The step executor downloaded the script from the object store, there by eliminating storing the scripts as part of the code base. The step executor is now a stateless component which worked based on the inputs that was passed to it. The below sequence explains on how the overall execution happened. </p>\n<p><img src=\"./images/migrationPlatform/Sequence-Orchestrator-StepExecutor.svg\"></p>\n<h2>Continuation</h2>\n<p>Orchestrator was able to capture the plan's information to generate an execution plan for the component creation. We did not develop any specific UI for the same and handled the values using migration scripts. We bundled the application with docker and deployed it into an <a href=\"https://cloud.google.com/kubernetes-engine\">GKE</a> cluster.</p>\n<p><img src=\"./images/migrationPlatform/Deployment-Orchestrator.svg\"></p>\n<p>In our next part, I'll talk about how we managed to provide user interaction using the mediator service. </p>\n","description":"Part 2 of a multi part blog, where I talk about how we built out a migration platform for moving from Azure to GCP","pagePath":"arunmadhavan-g/blogs","publishedOn":"2021-09-18T23:45:18.088Z","tags":["GCP","Spring Boot","Migration","Architecture"],"title":"Building A Cloud Migration Platform - Part 2 : Orchestration And Execution"}}},"staticQueryHashes":["2244550708"]}