{"componentChunkName":"component---src-templates-page-template-js","path":"/implementingATransientBpmForAMultiTenantSystem","result":{"pageContext":{"page":{"author":"Arun Madhavan","content":"<p>We had to, for one of our clients help them integrate Business process management(BPM) into their existing multi-tenant system, to power approval flows.\nThe solution had to </p>\n<ul>\n<li>Easily import a standard BPMN 2.0 based definition and also let create one as well.</li>\n<li>Work with multiple tenants and ensure data does not get shared between user of tenants.</li>\n<li>Be Open source to keep the cost involved low. </li>\n<li>Scale Easily.</li>\n<li>Be Customizable to meet their existing platform requirements. </li>\n</ul>\n<p>The rest of the talks about how we managed to accomplish that and the thought process that went into the building of the overall solution. </p>\n<h1>TL;DR</h1>\n<p>We integrated an Open Source Java based BPM system <a href=\"https://camunda.com/\">Camunda</a>, that provides a way to add the complete platform as a\nspring application. Also we did not store any user information into the Camunda system and leveraged it's APIs to</p>\n<ol>\n<li>Maintain the BPMN definition at the source system.</li>\n<li>For every need for a business process a new Deploy of BPMN definition is done at Camunda</li>\n<li>A task is then created to trigger the business process for the deployment. </li>\n<li>The deployment and task IDs were maintained in the source system</li>\n<li>Make call backs using Listeners to notify when the task is completes to the source system.</li>\n<li>Un-Deploy when the process completes. </li>\n</ol>\n<p>This helped us to keep things alive for a specific approval process and also helped maintain complete isolation between processes.\nThis also potentially cleared all the headaches of maintaining the users across two different systems. </p>\n<h1>BPMN : A quick intro</h1>\n<p>Let us consider an editorial example that involves the following work flow. </p>\n<ul>\n<li>An employee writes a piece of article and submits for review</li>\n<li>The article goes through a review engine, that based on the key words flags for sensitive material</li>\n<li>Based on the flagging level the article would go to  <ul>\n<li>Sub Editor in case of a normal one</li>\n<li>Senior editor in case it's sensitive</li>\n</ul></li>\n<li>The reviewer looked into the article and can <ul>\n<li>Approve it if it's good</li>\n<li>Send back if there are changes needed</li>\n<li>Reject it if it's not worth publishing</li>\n</ul></li>\n<li>After the above process the article gets<ul>\n<li>published and available for others to read if Approved</li>\n<li>sent back to the employee who can rework on it and go through the process again</li>\n<li>moves to the archive in case of Rejected</li>\n</ul></li>\n</ul>\n<p>Typically we have a flow that can be defined here. A similar parallel can be drawn against many such situations which also works with enterprises and processes such as </p>\n<ul>\n<li>Leave approval flow ( where it can be an immediate manager who would approve it )</li>\n<li>Procurement ( where there can be many levels of approval )</li>\n<li>Travel Requests  ... </li>\n</ul>\n<p>Typically the processes are defined by the business and there will be a team who would work on translating it to code.\nA BPM system acts as a bridge to make things more accessible to both the parties. </p>\n<p>It allows the business or the business analyst to draw the BLOCKS of and the connections between them. This is defined in the background as a XML following a standard called the BPMN2.0 notation.</p>\n<p><img src=\"./images/transientBPMN/simple-bpmn-flow.png\" alt=\"Simple BPMN\"></p>\n<p>Some of the types of blocks are</p>\n<ul>\n<li><strong>Start Node</strong> that indicates the start of a flow</li>\n<li><strong>Task Node</strong> which typically denotes an operation this can be <ul>\n<li><strong>User Task</strong> which needs a user to act upon ( like an approval process ) </li>\n<li><strong>Service Task</strong> which helps in doing pre-built tasks such as calling an API, performing calculations etc. </li>\n</ul></li>\n<li><strong>Conditional Node</strong> which performs a conditional operation and determins the next flow </li>\n<li><strong>End Node</strong> that denotes a completion of the flow</li>\n</ul>\n<p>The above figure shows these blocks put together to define a order approval workflow.  </p>\n<h1>Why Camunda</h1>\n<p>While assessing multiple BPM solutions, we wanted a tool that is</p>\n<ul>\n<li>BPMN 2.0 compliant</li>\n<li>Opensource to keep the cost ( related to licensing ) low. </li>\n<li>Easy to deploy and scale</li>\n<li>Ability to Customize easily for our requirements</li>\n<li>Decent community support for trouble shooting and upgrades</li>\n</ul>\n<p>We looked into a number of options and liked Camunda the most because it fulfilled most of our needs.\nIt also gave us the ability to wrap it up as a Spring Boot project with custom code handling.</p>\n<p>The document was decent ( there were definitely places where we wished it could have been more intutive) and the code organization was easy to understand.\nMost importantly it was build using Java, Spring and uses a RDBMS system in the backend which makes understanding and customizing it easier. </p>\n<h1>Camunda - Process flow</h1>\n<p>Before we get into solving the actual problem, a small primer on how Camunda works with respect to executing a BPM process. </p>\n<ul>\n<li>Every BPMN file that we upload is deployed. We'll call this a deployment. This is associated with a \"deploymentId\"</li>\n<li>After a BPMN is deployed, it can be started. The equivalent is like deploying an application in a server and it's ready to take requests. </li>\n<li>When an activity requires triggering of a business process, we use the \"deploymentId\" associated with the business process and we trigger a process. The process will be associated with a \"processId\"</li>\n<li>The process would typically consist of multiple task, each of which will be identified using a \"taskId\"</li>\n<li>Some of these tasks are user tasks.  User tasks will not execute until a user acts on it ( like an approve, reject, send back etc. )</li>\n<li>On completion of all the tasks, the process will also come to an end, leaving the BPM deployment to be alive. </li>\n</ul>\n<p><img src=\"./images/transientBPMN/Camunda-Block.jpg\" alt=\"Deployment-Process-Task\"></p>\n<p>So every BPMN process that we need to execute will have it's own deployment.\nThis deployment can inturn have multiple processes which inturn can have multiple tasks. </p>\n<p>As a special note, while executing user tasks, the user who needs to act on it (or a group of users in some cases), should be a part of Camunda's users to be able to perform the activity on the task.\nThe user would have their own login and a list of work items they can act upon (examples tasks that require approvals).</p>\n<p>Each process would relate to a specific business process execution.  With this primer in mind, we'll continue to the problem statement. </p>\n<h1>The Requirement - (Multi-Tenant X Multi-Processes)</h1>\n<p>The existing consists of an admin user (admin) and a normal user (user). The user can use the system to raise different kinds of requests.\nEach request would now go to the admin for their approval and following which they get fulfilled.</p>\n<p>Our customer wanted this to be changed to use a BPMN based flow to </p>\n<ul>\n<li>Avoid having single point of failure on the Admin user for all the requests</li>\n<li>Adopt the system for enterprise usecases where typically depending on the type of the request, it would go through a different set of flow</li>\n</ul>\n<p>Basically they wanted the ability to be able ot define different types of approval flow, and attach each types of request with a specific approval flow.\nA few examples to make this more clear</p>\n<ul>\n<li>For a request type which may involve \"install Firefox browser\" in a user's machine may not need any approvals</li>\n<li>A request to apply for a duplicate ID card request would need approval from \"reporing manager\"</li>\n<li>A request to create an S3 bucket for their project would need approval from  \"reporting manager\", \"architecture team\" and \"Finance Team\"</li>\n</ul>\n<p>So in each of the situations we will have a corresponding work flow defined to handle the approval flows.\nTypially this means the user to whom the approval would be assigned to would be determined runtime, based on the requesting user/ type of request.\nSimilarly the same approval may go to an individual (e.g. reporting manager) or to a group of people (e.g. Finance team).  We call the former an hierarchial approval as it's based on an hierarchy and the latter a group approval as it's just assigning it to a group.\nIn most cases the user details of the tenants were coming from LDAP which means getting the corresponding user / users details at run time would be a query against thei LDAP. </p>\n<p>This means we need to handle the following</p>\n<ol>\n<li>Have the ability to define different BPM processes in the system ( defined using BPMN )</li>\n<li>Associate all the requests types with a corresponding BPM process</li>\n<li>On creation of a request, depending on the type use the corresponding BPM process</li>\n<li>Depending on the BPM process, have the ability to search for and assign approval to a user / group of users. </li>\n</ol>\n<p>It just get's better when these needs to be handled for multiple tenants as well.  Which means we need to bring</p>\n<ul>\n<li>isolation of process acroess tenants</li>\n<li>isolation of users across different tenants</li>\n<li>Depending on the tenant, the querying from LDAP will vary and that should be accomodated as a configuration.</li>\n</ul>\n<h1>The First Iteration</h1>\n<p>Solving problems 1 and 2 looked quite straight forward. The BPMN definitions were created as deployments in Camunda.\nIt's deployment ID and process Id were put into a workflow definition table along with meta-information such as name and description.\nWe ran a migration against the requestType table to include an extra column holding the workflowId and associate it with the corresponding workflow type.\nWith this we were able to trigger a workflow everytime a request was created. </p>\n<p>This is where our next challenge arose, </p>\n<h2>User Management Conundrum</h2>\n<p>We had to figure out the following,\n1. Based on the logged in user, find the corresponding person to which the approval needs to be assigned to in case of hierarchial approvals\n2. Based on the user logged in show them the approvals pending their action. </p>\n<p>For this we integrated Camunda into our SSO, wrote scripts to replicate the same set of users into Camunda's database and run them regularly to keep them in sync. We also integrated Camunda with LDAP directly to pull the user details and take care of the assignments (both hierarchial and group). But then came the issue. </p>\n<p>We had to do this for a multi-tenant system, which means we are going to </p>\n<ol>\n<li>Bring all the users across individual tenants into Camunda</li>\n<li>Keep them synced up ( both creates and deletes )</li>\n<li>Ensure isolation between tenants</li>\n<li>Handle growing data in the database</li>\n<li>Figure out errors/ crashes between systems and eventual data sync up etc. etc. </li>\n</ol>\n<p>This started to bring in a lot of moving parts. On top of this we were trying to re-invent the same things that we had already handled as part of the main application, for example the LDAP searches, tenant level isolation, email notification etc. The amount of work to ensure everything works was starting to build up and the fact that there were too many moving parts and multiple sources of truth could make maintenance a nightmare.  </p>\n<p>Camunda does give us the ability to create different tenants which helps with isolation to a large extent, but it was still a concern with all the data sync up and logic duplication.</p>\n<h2>Deployment - Overflow</h2>\n<p>To add to the growing user, sync up issue, we found another one. The number of BPMN deployments grew, and it grew wild. </p>\n<p>Every tenant brought in their own BPMN files, each of which were creating their own deployment and every one of them started showing up in the console. This looked pretty messed up especially and with more tenants expected to be onboard, we were definitely staring at a maintenance nightmare.</p>\n<p>We had to rethink our implementation strategy. </p>\n<h1>Keeping it Simple</h1>\n<p>The first thing that we wanted to address was to reduce the moving parts. To achieve the same we decided to do the following</p>\n<ul>\n<li>\n<p>Look at a way to maintain a single source of truth. If the data duplication between Camunda and application be avoided then let's do that. </p>\n</li>\n<li>\n<p>Try to leverage the existing functionality in the application instead of replicating the same in Camunda end. For example using the email service, LDAP lookup in the application can be leveraged rather than replicating it every time. </p>\n</li>\n<li>\n<p>Handle multi tenance as part of application and not as part of the camunda. This would again reduce the number of configurations that would have to be done at the camunda end to ensure data isolation. </p>\n</li>\n<li>\n<p>Think of a good way to solve the deployment explosion. </p>\n</li>\n</ul>\n<p>Basically we wanted to have a system which has minimal of no information with itself and only work with the inputs passed to it.  Basically a dumb system that does only one work. Run workflows.  </p>\n<h2>Runtime deployments</h2>\n<p>To avoid the deployment explosion problem, we decided that anyone who uploads a BPMN file to the system to implement their approval flow, we would not be doing a deployment into Camunda.</p>\n<p>Instead we uploaded the files into an S3 bucket and stored it's details into the workflow table. Everytime a request was created which required a specific type of workflow, we leveraged the camunda API that would</p>\n<ul>\n<li>Download the bpmn file from S3.</li>\n<li>Make an API call to deploy this BPMN definition. This returns the deployment Id.</li>\n<li>Not follow the previous path of initiating a process for this deployment Id. </li>\n<li>Once all the tasks are completed, we made camunda talk back to the application to mark the workflow as complete.</li>\n<li>This triggers another API call to undeploy the definition. </li>\n</ul>\n<p>This suddenly made all the persistent deployments to disappear from the camunda console. All that we were able to see are those which are in progress. </p>\n<p>This kept things simple and massively reduced the headache of figuring out which deployment is for what.  </p>\n<p><img src=\"./images/transientBPMN/MultiDeploy.png\" alt=\"Multi Deploy\"></p>\n<h2>Transient and Statelesss</h2>\n<p>Now that we solved the issue with the deployment overflow resolved, we wanted to work on the duplication of data part between the systems. We still needed users to act on their tasks which means the user had to be synced.</p>\n<p>This is when we explored using the Listeners for the user tasks. By now the complete deployment and kick starting a process was all handled as part of the core applicaiton using camunda APIs.\nWe now added a new endpoint in the main application that would</p>\n<ul>\n<li>Take the task Id of the camunda user task</li>\n<li>The request Id for which the workflow is running</li>\n<li>The type of approval that needs to happen which can be hierarchial or group in this case.</li>\n</ul>\n<p>We wrote custom TaskListeners in the Camunda Spring application and made it trigger this endpoint with the appropriate details on the task \"create\" lifecycle. </p>\n<p>So this would make as call to the base application, where using the already available LDAP search capability, the corresponding user(s) who needs to act on the approval is identified and and entry is made into a table with the userId, the requesting user Id, the task Id from Camunda and request Id. </p>\n<p>This information is presented in pending approval screen which was not in camunda anymore. When the user acts on the same, we trigger the camunda API to update the corresponding task.  To close the loop as part of the \"complete\" lifecycle, we make another endpoint call that would mark this task as complete in the base application.</p>\n<p><img src=\"./images/transientBPMN/TransientFlow.png\" alt=\"Transient Flow\"></p>\n<p>This gave us the ability to completely manage the user as part of the base application and eliminated any need for replicating the users. All that we needed was an admin account and a secure password which was used by the application to make the rest api calls. </p>\n<h2>Isolation</h2>\n<p>The last change eliminated the need to </p>\n<ul>\n<li>Configure SSO </li>\n<li>Expose Camunda to the end user</li>\n<li>Have convoluted processes in place to manage the overall application</li>\n<li>Duplicating a number of functionalities that are already in place in the base application. </li>\n</ul>\n<p>The best part was we did not have to expose camunda to the external world at all as all user interactions with the system is not eliminated. </p>\n<p>So we were able to move it to a VPN that was isolated from the public facing internet.\nAlso the fact that each user approval was a separate deployment, ensured data isolation.\nWith all this multi-tenancy and fear of differnet tenant information getting mixed up was also eliminated. </p>\n<p><img src=\"./images/transientBPMN/Isolation.png\" alt=\"Isolation\"></p>\n<p>So we were able to get tenant level, user level, network level and system level isolation making this quite a secure implementation. </p>\n<h1>Summary</h1>\n<p>We were able to move from a high maintenace, tightly coupled system to a more loosely couples system.</p>\n<p>In the process we achieved better isolation between tenants and also ensured that the individual systems were capable of scaling easily as well.</p>\n","description":"I share my experience with how I integrated a BPM system for a multi-tenant solution, and kept it transient to keep things simple","pagePath":"arunmadhavan-g/blogs","publishedOn":"2020-04-19T12:39:18.088Z","tags":["Java","Spring","BPM"],"title":"Implementing a transient BPM for a multi-tenant system"}}}}